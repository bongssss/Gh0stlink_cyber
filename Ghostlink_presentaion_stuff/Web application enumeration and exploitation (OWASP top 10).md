Open Web Application Security Project, includes a globally recognised list of the most important web app security risks

The current OWASP top 10 include
- **Broken Authentication/access** control (forced browsing)
this occurs when users can implement vertical or horizontal privilege escalation without role-based access control or server-side authorisation. some broken access controls include vertical, horizontal and another example is the IDOR vulnerability (insecure Direct Object Reference)

- **cryptographic failures** 
happen as a result of lack of proper encryption or no encryption at all i.e., transmitting sensitive data over http and not https or using md5sum or sha1 which are outdated

- injections, i.e., input/ sql injections
occurs when untrusted data is sent to an interpreter as part of a command or query i.e., imputing something in a login field that helps bypass authentication types include active and blind command injections
    SQL Injection: This occurs when user-controlled input is passed to SQL queries. As a result, an attacker can pass in SQL queries to manipulate the outcome of such queries. This could potentially allow the attacker to access, modify and delete information in a database when this input is passed into database queries. This would mean an attacker could steal sensitive information such as personal details and credentials.
    Command Injection: This occurs when user input is passed to system commands. As a result, an attacker can execute arbitrary system commands on application servers, potentially allowing them to access users' systems.

- **insecure design**
Concerns flaws in the application architecture and design that create security risks. It often includes missing or ineffective security controls, i.e., Allowing password resets without verifying user identity.

- **security misconfigurations**
Happens when security settings are improperly set or left as insecure defaults.
Security misconfigurations include:

- Poorly configured permissions on cloud services, like S3 buckets.
- Having unnecessary features enabled, like services, pages, accounts or privileges.
- Default accounts with unchanged passwords.
- Error messages that are overly detailed and allow attackers to find out more about the system.
- Not using [HTTP security headers](https://owasp.org/www-project-secure-headers/).
Debugging Interfaces

A common security misconfiguration concerns the exposure of debugging features in production software. Debugging features are often available in programming frameworks to allow the developers to access advanced functionality that is useful for debugging an application while it's being developed. Attackers could abuse some of those debug functionalities if somehow, the developers forgot to disable them before publishing their applications.One example of such a vulnerability was allegedly used when [Patreon got hacked in 2015](https://labs.detectify.com/2015/10/02/how-patreon-got-hacked-publicly-exposed-werkzeug-debugger/). Five days before Patreon was hacked, a security researcher reported to Patreon that he had found an open debug interface for a Werkzeug console. Werkzeug is a vital component in Python-based web applications as it provides an interface for web servers to execute the Python code. Werkzeug includes a debug console that can be accessed either via URL on `/console`, or it will also be presented to the user if an exception is raised by the application. In both cases, the console provides a Python console that will run any code you send to it. For an attacker, this means he can execute commands arbitrarily.

- **vulnerable and outdated components**
Applications that use components with known vulnerabilities can be easily compromised.

- **identification and authentication flaws/failures** 
They refer to Weaknesses in the authentication mechanism. i.e., Weak passwords, no rate limiting, predictable session tokens.

- **software and data integrity failures** 
Applications rely on external sources like packages and updates that can be tampered with. i.e., Installing a malicious library or compromised CI/CD pipeline.

- **software logging and monitoring flaws**
Lack of proper logging and monitoring delays responses to breaches or breach detection. i.e., No logs for login failures

- **serverside request forgery**
Occurs when an application fetches a remote resource based on user input.


**Secure Coding & Prevention Practices**
•Validate inputs and encode outputs.
•Use HTTPS and strong encryption.
•Implement RBAC and least privilege.
•Regularly update and patch systems.
•Conduct security reviews and code audits.
•Follow a secure SDLC.


### OWASP top 10 Exploit Documentation


7. **Identification and authentication failures**
authentication and Identification flaws/failures:
The most common form of authentication is using a username and password mechanism. A user would enter these credentials, and the server would verify them. The server would then provide the users' browser with a session cookie if they are correct. A session cookie is needed because web servers use HTTP(S) to communicate, which is stateless. Attaching session cookies means the server will know who is sending what data. The server can then keep track of users' actions. 
some common flaws include: brute-force attacks, allowing the use of weak credentials by setting weak password policies, weak session cookies with predictable values
mitigation: Multi-factor authentication, automatic lockout after a number of attempts and implementing strong password policies.


Practical implementation: exploiting authentication and Identification flaws/failures to re-register an existing user due to weak credential enforcement policy. 
*steps :*
- I connected to THM servers via opvn
![[ovpn connection.png]]
- Then gain access to the website but before that I check my internet IP address provided by the vpn 
![[thm_owasp7cont.jpg]]
now I access the website here: http://10.10.72.184:8088/
- I exploit weak authentication and identification via the weak credential enforcement policy on the website by reregistering the user `darren` and `arthur` and gaining access to their sensitive data.


8. Software and Data integrity failures:
to ensure integrity of data, i.e., files; hashes are usually sent alongside to be able to prove that the identity of the file matches the hash this mechanism of getting hashes along with files to heck the data integrity of these files is called subresource integrity; It allows web developers to ensure that resources hosted on third-party servers have not been tampered with. Use of SRI https://www.srihash.org/is recommended as a best-practice, whenever libraries are loaded from a third-party source.

When software systems use data without rigorous integrity checks, they are vulnerable to data integrity failures.


JSON Web Tokens JWTs are very simple tokens that allow you to store key-value pairs on a token that provides integrity as part of the token. The idea is that you can generate tokens that you can give your users with the certainty that they won't be able to alter the key-value pairs and pass the integrity check. The structure of a JWT token is formed of 3 parts seperated by periods like so `eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6Imd1ZXN0IiwiZXhwIjoxNjY1MDc2ODM2fQ.C8Z3gJ7wPgVLvEUonaieJWBJBYt5xOph2CpIhlxqdUw`:
`The header` contains metadata indicating this is a JWT, and the signing algorithm in use which is usually 'HS256'. 

`The payload` contains the key-value pairs with the data that the web application wants the client to store. 

`The signature` is similar to a hash, taken to verify the payload's integrity. If you change the payload, the web application can verify that the signature won't match the payload and know that you tampered with the JWT. 

Unlike a simple hash, this signature involves the use of a secret key held by the server only, which means that if you change the payload, you won't be able to generate the matching signature unless you know the secret key. 

each of the 3 parts of the token is simply plaintext encoded with base64. You can use this online tool `https://appdevtools.com/base64-encoder-decoder` to encode/decode base64

![[anatomy of a JSON Web Token (JWT).png]]

9. Security logging and monitoring failures

The information stored in logs should include the following:

    HTTP status codes
    Time Stamps
    Usernames
    API endpoints/page locations
    IP addresses
These logs have some sensitive information, so it's important to ensure that they are stored securely and that multiple copies of these logs are stored at different locations.

10. Server Side request forgery 
server Side request forgery 

Think, for example, of a web application that uses an external API to send SMS notifications to its clients. For each email, the website needs to make a web request to the SMS provider's server to send the content of the message to be sent. Since the SMS provider charges per message, they require you to add a secret key, which they pre-assign to you, to each request you make to their API. The API key serves as an authentication token and allows the provider to know to whom to bill each message.![[serverside request forgery.png]]
In general, depending on the specifics of each scenario, SSRF can be used for:

- Enumerate internal networks, including IP addresses and ports.
- Abuse trust relationships between servers and gain access to otherwise restricted services.
- Interact with some non-HTTP services to get remote code execution (RCE).